// Содержимое файла main.c

#include "MDR32Fx.h"                    // Device header
#include "MDR32F9Qx_config.h"           // Keil::Device:Startup

#include <MDR32F9Qx_port.h>
#include <MDR32F9Qx_rst_clk.h>
#include "MDR32F9Qx_uart.h"             // Keil::Drivers:UART

#include "MDR32F9Qx_i2c.h"              // Keil::Drivers:I2C
#include "MDR32F9Qx_adc.h"              // Keil::Drivers:ADC

int j;
int T;

#define DELAY1(D) for (j = D; j > 0; j--)

//  Прототип функции задержки, реализованной ниже
void Delay(int waitTicks);
void LED_ini(void);
void Interrupt_ini(void);
void UART_ini(void);
void ADC_ini(void);




void LED_ini(void)
{
	// Заводим структуру конфигурации вывода(-ов) порта GPIO
	PORT_InitTypeDef GPIOInitStruct;
	
	//  Включаем тактирование порта C
	RST_CLK_PCLKcmd (RST_CLK_PCLK_PORTC, ENABLE);
	
	//  Инициализируем структуру конфигурации вывода(-ов) порта значениями по 
	//  умолчанию
	PORT_StructInit(&GPIOInitStruct);
  
	//  Изменяем значения по умолчанию на необходимые нам настройки
	GPIOInitStruct.PORT_Pin        = PORT_Pin_0;
	GPIOInitStruct.PORT_OE         = PORT_OE_OUT; // Default is IN
	GPIOInitStruct.PORT_PULL_UP	   = PORT_PULL_UP_OFF; // Default is OFF
	GPIOInitStruct.PORT_PULL_DOWN  = PORT_PULL_DOWN_ON; // Default is OFF
	GPIOInitStruct.PORT_PD_SHM	   = PORT_PD_SHM_OFF; // Default is OFF
	GPIOInitStruct.PORT_PD		   = PORT_PD_DRIVER; // Default is DRIVER
	GPIOInitStruct.PORT_GFEN	   = PORT_GFEN_OFF; // Default is OFF
	GPIOInitStruct.PORT_FUNC	   = PORT_FUNC_PORT; // Default is PORT
	GPIOInitStruct.PORT_SPEED      = PORT_SPEED_SLOW; // Default is OFF
	GPIOInitStruct.PORT_MODE       = PORT_MODE_DIGITAL; // Default is ANALOG
  
	//  Применяем заполненную нами структуру для PORTC.
	PORT_Init(MDR_PORTC, &GPIOInitStruct);
}


void Button_ini(void)
{
	RST_CLK_PCLKcmd (RST_CLK_PCLK_PORTC, ENABLE);
	PORT_InitTypeDef ButtonInitStruct;
	PORT_StructInit(&ButtonInitStruct);
	// Изменяем значения по умолчанию на необходимые нам настройки
	ButtonInitStruct.PORT_Pin   = PORT_Pin_10;
	ButtonInitStruct.PORT_GFEN	= PORT_GFEN_OFF; // Default is OFF
	ButtonInitStruct.PORT_FUNC	= PORT_FUNC_ALTER; // Default is PORT
	ButtonInitStruct.PORT_SPEED = PORT_SPEED_SLOW; // Default is OFF
	ButtonInitStruct.PORT_MODE  = PORT_MODE_DIGITAL; // Default is ANALOG
	PORT_Init(MDR_PORTB, &ButtonInitStruct);
	
	
}

void Interrupt_ini(void)
{
	NVIC_ClearPendingIRQ(EXT_INT2_IRQn); // Reset external interrupt flag
	__enable_irq(); // Enable interrupts
	NVIC_EnableIRQ(EXT_INT2_IRQn); // Enable external interrupt
}

// Процедура обработки внешнего прерывания EXT_INT2
void EXT_INT2_IRQHandler(void) 
{ 
	// Уменьшение времени задержки, 
	// т.е. увеличение частоты мигания светодиода 
	T = T - 50000; // Если задержка равна нулю, 
	// то возвращение в исходное состояние 
	if (T == 0) T = 200000; 
	// Задержка, в течение которой прекращается дребезг контактов 
	DELAY1(100000); 
	// Если сигнал внешнего прерывания завершен,
	// очистить флаг внешнего прерывания EXT_INT2 
	if (PORT_ReadInputDataBit(MDR_PORTB, PORT_Pin_10) == 0)
	{
		NVIC_ClearPendingIRQ(EXT_INT2_IRQn); 
	}
}

void UART_ini(void)
{
	PORT_InitTypeDef GPIOInitStruct;
	
	RST_CLK_PCLKcmd (RST_CLK_PCLK_PORTA, ENABLE);
		
	PORT_DeInit(MDR_PORTA);
	
	GPIOInitStruct.PORT_Pin        = PORT_Pin_7;
	GPIOInitStruct.PORT_OE         = PORT_OE_OUT; // Default is IN
	GPIOInitStruct.PORT_PULL_UP	   = PORT_PULL_UP_OFF; // Default is OFF
	GPIOInitStruct.PORT_PULL_DOWN  = PORT_PULL_DOWN_OFF; // Default is OFF
	GPIOInitStruct.PORT_PD_SHM	   = PORT_PD_SHM_OFF; // Default is OFF
	GPIOInitStruct.PORT_PD		   = PORT_PD_DRIVER; // Default is DRIVER
	GPIOInitStruct.PORT_GFEN	   = PORT_GFEN_OFF; // Default is OFF
	GPIOInitStruct.PORT_FUNC	   = PORT_FUNC_OVERRID; // Default is PORT
	GPIOInitStruct.PORT_SPEED      = PORT_SPEED_MAXFAST; // Default is OFF
	GPIOInitStruct.PORT_MODE       = PORT_MODE_DIGITAL; // Default is ANALOG
	
	PORT_Init(MDR_PORTA, &GPIOInitStruct);
	
	
	UART_InitTypeDef UARTInitStruct;
	
	// Enable UART1 clocking
	RST_CLK_PCLKcmd (RST_CLK_PCLK_UART1, ENABLE);
	
	UART_BRGInit(MDR_UART1, UART_HCLKdiv1);
	
	UARTInitStruct.UART_BaudRate			 = 9600;
	UARTInitStruct.UART_WordLength			 = UART_WordLength8b;
	UARTInitStruct.UART_StopBits			 = UART_StopBits1;
	UARTInitStruct.UART_Parity				 = UART_Parity_No;
	UARTInitStruct.UART_FIFOMode			 = UART_FIFO_OFF;
	UARTInitStruct.UART_HardwareFlowControl  = UART_HardwareFlowControl_TXE;
	
	// Initialize UART1
	UART_Init(MDR_UART1, &UARTInitStruct);
	
	// Turn on UART1
	UART_Cmd(MDR_UART1, ENABLE);
}

void ADC_ini(void)
{
	__IO uint32_t H_Level = 0x900;
	__IO uint32_t L_Level = 0x800;
	
	PORT_InitTypeDef PORT_InitStructure;
	ADC_InitTypeDef sADC;
	ADCx_InitTypeDef sADCx;
	
	RST_CLK_DeInit();
	RST_CLK_CPU_PLLconfig (RST_CLK_CPU_PLLsrcHSIdiv2,0);
	/* Enable peripheral clocks --------------------------------------------------*/
	RST_CLK_PCLKcmd((RST_CLK_PCLK_RST_CLK | RST_CLK_PCLK_ADC | RST_CLK_PCLK_PORTD),ENABLE);

	/* Init NVIC */
	SCB->AIRCR = 0x05FA0000 | ((uint32_t)0x500);
	SCB->VTOR = 0x08000000;
	/* Disable all interrupt */
	NVIC->ICPR[0] = 0xFFFFFFFF;
	NVIC->ICER[0] = 0xFFFFFFFF;

	/* Enable ADC interrupt  */
	NVIC->ISER[0] = (1<<ADC_IRQn);
	
	/* Reset PORTD settings */
	PORT_DeInit(MDR_PORTD);
	
	/* Configure ADC pin: ADC7 */
	/* Configure PORTD pin 7 */
	PORT_InitStructure.PORT_Pin   = PORT_Pin_7;
	PORT_InitStructure.PORT_OE    = PORT_OE_IN;
	PORT_InitStructure.PORT_MODE  = PORT_MODE_ANALOG;
	
	PORT_Init(MDR_PORTD, &PORT_InitStructure);
	
	/* Configure PORTD pins 10, 11 for output to switch LED1,2 on/off */ 
	/* Configure PORTD pins 10, 11 */
	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_PORT;
	PORT_InitStructure.PORT_Pin   = PORT_Pin_10 | PORT_Pin_11 | PORT_Pin_12;
	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
	
	PORT_Init(MDR_PORTD, &PORT_InitStructure);
	
	
	ADC_DeInit(); // Reset all ADC settings
	
	//Fills each ADC_InitStruct member with its default value
	ADC_StructInit(&sADC);
	
	/* Initializes the ADC peripheral according to
	the specified parameters in the ADC_InitStruct */
	ADC_Init(&sADC);
	
	//Fills each ADCx_InitStruct member with its default value.
	ADCx_StructInit (&sADCx);
	/*  ADCx_StructInit fills with default values
	*	sADCx.ADC_ClockSource 	   //Default ADC_CLOCK_SOURCE_CPU
	*	sADCx.ADC_SamplingMode	   //Default ADC_SAMPLING_MODE_SINGLE_CONV
	*	sADCx.ADC_ChannelSwitching //ADC_CH_SWITCHING_Disable
	*	sADCx.ADC_ChannelNumber	   //ADC_CH_ADC0
	*	sADCx.ADC_Channels		   //Default 0
	*	sADCx.ADC_LevelControl	   //Default ADC_LEVEL_CONTROL_Disable
	*	sADCx.ADC_LowLevel		   //Default 0
	*	sADCx.ADC_HighLevel		   //Default 0
	*	sADCx.ADC_VRefSource	   //Default ADC_VREF_SOURCE_INTERNAL
	*	sADCx.ADC_IntVRefSource	   //Default ADC_INT_VREF_SOURCE_INEXACT
	*	sADCx.ADC_Prescaler		   //Default ADC_CLK_div_None
	*	sADCx.ADC_DelayGo		   //Default 0
	*/
	sADCx.ADC_ClockSource      = ADC_CLOCK_SOURCE_CPU; //выбор источника тактирования, частота ядра
	sADCx.ADC_SamplingMode     = ADC_SAMPLING_MODE_CICLIC_CONV; //режим многократного преобразования
	sADCx.ADC_ChannelSwitching = ADC_CH_SWITCHING_Disable; // автоматическое переключение каналов
	sADCx.ADC_ChannelNumber    = ADC_CH_ADC7; //выбор номера канала
	sADCx.ADC_Channels         = 0; //количество используемых каналов, если включен перебор ADC_CH_SWITCHING_Enable
	sADCx.ADC_LevelControl     = ADC_LEVEL_CONTROL_Enable; // контроль уровня входного сигнала
	sADCx.ADC_LowLevel         = L_Level;//нижний уровень контроля
	sADCx.ADC_HighLevel        = H_Level; // верхний уровень
	sADCx.ADC_VRefSource       = ADC_VREF_SOURCE_INTERNAL; //выбор внутреннего источника опорного напряжения
	sADCx.ADC_IntVRefSource    = ADC_INT_VREF_SOURCE_INEXACT; //вид источника для датчика опорного напряжения
	sADCx.ADC_Prescaler        = ADC_CLK_div_32768; //выбор делителя тактовой частоты
	sADCx.ADC_DelayGo          = 0xF; //значение задержки перед началом следующего преобразования
	
	/* Initializes the ADC1 peripheral according to
	the specified parameters in the ADCx_InitStruct */
	ADC1_Init(&sADCx);
	
	/* Enable ADC1 EOCIF and AWOIFEN interupts */
	ADC1_ITConfig((ADCx_IT_END_OF_CONVERSION | ADCx_IT_OUT_OF_RANGE), ENABLE);

	/* ADC1 enable */
	ADC1_Cmd(ENABLE);
}


//  Простейшая функция задержки, позднее мы заменим ее на реализацию через 
//  таймер
void Delay(int waitTicks)
{
	int i;
	for (i = 0; i < waitTicks; i++)
	{
		__NOP();
	}
}

//  Точка входа, отсюда начинается исполнение программы

int main(void)
{
	LED_ini();
	Interrupt_ini();
	Button_ini();
	
	T = 200000;
	
	//  Запускаем бесконечный цикл обработки - Основной цикл	
	while (1)	
	{
		// Считываем состояние вывода PC0
		// Если на выводе логический "0", то выставляем вывод в логическую "1"
		if (PORT_ReadInputDataBit (MDR_PORTC, PORT_Pin_0) == 0)
		{
			PORT_SetBits(MDR_PORTC, PORT_Pin_0);
		}
    
		//  Задержка
		Delay(T);

		// Считываем состояние вывода PC0
		// Если на выводе = "1", то выставляем "0"
		if (PORT_ReadInputDataBit (MDR_PORTC, PORT_Pin_0) == 1)
		{
			PORT_ResetBits(MDR_PORTC, PORT_Pin_0);
		}
		
		//  Задержка    
		Delay(T);
	}
}