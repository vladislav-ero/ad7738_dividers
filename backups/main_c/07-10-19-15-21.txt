// Содержимое файла main.c

#include "MDR32Fx.h"                    // Device header
#include "MDR32F9Qx_config.h"           // Keil::Device:Startup

#include "MDR32F9Qx_uart.h"             // Keil::Drivers:UART
#include <MDR32F9Qx_port.h>
#include <MDR32F9Qx_rst_clk.h>
#include "MDR32F9Qx_timer.h"            // Keil::Drivers:TIMER
#include "MDR32F9Qx_i2c.h"              // Keil::Drivers:I2C
#include "MDR32F9Qx_adc.h"              // Keil::Drivers:ADC

void UART(void);
void LED(void);
	

void Timer1_IRQHandler()
{
	// Check if TIMER1 interrupt has occured
	if (TIMER_GetITStatus(MDR_TIMER1, TIMER_STATUS_CNT_ZERO)) 
		UART();
	
	// Reset TIMER1 interruption flag
	TIMER_ClearITPendingBit(MDR_TIMER1, TIMER_STATUS_CNT_ZERO);
}

void UART(void) {
	static uint8_t uart_counter = 1;
	switch (uart_counter++ % 6) {
		case 0:
			UART_SendData(MDR_UART2, '\r');
			LED();
		case 1:
			UART_SendData(MDR_UART2, 'U');
			LED();
		case 2:
			UART_SendData(MDR_UART2, 'A');
			LED();
		case 3:
			UART_SendData(MDR_UART2, 'R');
			LED();
		case 4:
			UART_SendData(MDR_UART2, 'T');
			LED();
		case 5:
			UART_SendData(MDR_UART2, '\n');
			LED();
	}
}

// Процедура включения/выключения светодиода 
void LED(void) { 
	// Объявление переменной i 
	static uint8_t led_counter = 0; 
	// Инкрементируя i, находить остаток от деления i на 2 
	switch (led_counter++ % 2) { 
		// В случае если остаток равен нулю, сбросить бит по линии 0 
		case 0: 
			PORT_ResetBits(MDR_PORTC, PORT_Pin_0); 
		// В противном случае перейти к следующей команде 
		break; 
		// В случае если остаток равен единице, установить бит по ли-нии 0 
		case 1: 
			PORT_SetBits(MDR_PORTC, PORT_Pin_0); 
		// В противном случае перейти к следующей команде 
		break; 
	} 
}

void Ports_ini(void)
{
	PORT_InitTypeDef NastroykaUART; 
	RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTF, ENABLE); 
	PORT_StructInit(&NastroykaUART);
	// Operation in UART mode 
	NastroykaUART.PORT_FUNC  = PORT_FUNC_OVERRID;
	NastroykaUART.PORT_SPEED = PORT_SPEED_MAXFAST;
	NastroykaUART.PORT_MODE  = PORT_MODE_DIGITAL;	
	// PF1 as UART_TX
	NastroykaUART.PORT_Pin   = PORT_Pin_1;
	NastroykaUART.PORT_OE    = PORT_OE_OUT;
	PORT_Init(MDR_PORTF, &NastroykaUART);
	// PF0 as UART_RX
	NastroykaUART.PORT_Pin   = PORT_Pin_0;
	NastroykaUART.PORT_OE    = PORT_OE_IN;
	PORT_Init(MDR_PORTF, &NastroykaUART);
	
	PORT_InitTypeDef NastroykaLED; 
	RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTC, ENABLE); 
	PORT_StructInit(&NastroykaLED); 
	NastroykaLED.PORT_Pin   = PORT_Pin_0; 
	NastroykaLED.PORT_OE    = PORT_OE_OUT; 
	NastroykaLED.PORT_FUNC  = PORT_FUNC_PORT; 
	NastroykaLED.PORT_MODE  = PORT_MODE_DIGITAL; 
	NastroykaLED.PORT_SPEED = PORT_SPEED_SLOW; 
	PORT_Init(MDR_PORTC, &NastroykaLED);
}



void LED_ini(void)
{
	// Включаем тактирование порта C
	RST_CLK_PCLKcmd (RST_CLK_PCLK_PORTC, ENABLE);
	
	// Заводим структуру конфигурации вывода(-ов) порта GPIO
	PORT_InitTypeDef GPIOInitStruct;
	
	// Инициализируем структуру конфигурации вывода(-ов) порта значениями по 
	// умолчанию
	PORT_StructInit(&GPIOInitStruct);
  
	// Изменяем значения по умолчанию на необходимые нам настройки
	GPIOInitStruct.PORT_Pin        = PORT_Pin_0;
	GPIOInitStruct.PORT_OE         = PORT_OE_OUT;       // Default is IN
	GPIOInitStruct.PORT_PULL_UP	   = PORT_PULL_UP_OFF;  // Default is OFF
	GPIOInitStruct.PORT_PULL_DOWN  = PORT_PULL_DOWN_ON; // Default is OFF
	GPIOInitStruct.PORT_PD_SHM	   = PORT_PD_SHM_OFF;   // Default is OFF
	GPIOInitStruct.PORT_PD		   = PORT_PD_DRIVER;    // Default is DRIVER
	GPIOInitStruct.PORT_GFEN	   = PORT_GFEN_OFF;     // Default is OFF
	GPIOInitStruct.PORT_FUNC	   = PORT_FUNC_PORT;    // Default is PORT
	GPIOInitStruct.PORT_SPEED      = PORT_SPEED_SLOW;   // Default is OFF
	GPIOInitStruct.PORT_MODE       = PORT_MODE_DIGITAL; // Default is ANALOG
  
	// Применяем заполненную нами структуру для PORTC.
	PORT_Init(MDR_PORTC, &GPIOInitStruct);
}


void Button_ini(void)
{
	RST_CLK_PCLKcmd (RST_CLK_PCLK_PORTB, ENABLE);
	PORT_InitTypeDef ButtonInitStruct;
	PORT_StructInit(&ButtonInitStruct);
	// Изменяем значения по умолчанию на необходимые нам настройки
	ButtonInitStruct.PORT_Pin   = PORT_Pin_10;
	ButtonInitStruct.PORT_GFEN	= PORT_GFEN_OFF;     // Default is OFF
	ButtonInitStruct.PORT_FUNC	= PORT_FUNC_ALTER;   // Default is PORT
	ButtonInitStruct.PORT_SPEED = PORT_SPEED_SLOW;   // Default is OFF
	ButtonInitStruct.PORT_MODE  = PORT_MODE_DIGITAL; // Default is ANALOG
	PORT_Init(MDR_PORTB, &ButtonInitStruct);
}

void Interrupt_ini(void)
{
	NVIC_ClearPendingIRQ(EXT_INT2_IRQn); // Reset external interrupt flag
	__enable_irq();                      // Enable interrupts
	NVIC_EnableIRQ(EXT_INT2_IRQn);       // Enable external interrupt
}

void Timer_ini(void)
{
	RST_CLK_PCLKcmd(RST_CLK_PCLK_TIMER1, ENABLE); // Enable Timer1 clocking
	TIMER_CntInitTypeDef TimerInitStruct;
	TIMER_CntStructInit(&TimerInitStruct);
	
	TIMER_BRGInit(MDR_TIMER1, TIMER_HCLKdiv1); // Set clock divider

	TimerInitStruct.TIMER_Prescaler = 8000; // CPUclk 8M div n == 8/n Hz (1 ms)
	TimerInitStruct.TIMER_Period    = 100;  // 1 ms * n == n ms
	
	TIMER_CntInit(MDR_TIMER1, &TimerInitStruct);
	
	NVIC_EnableIRQ(Timer1_IRQn); // Enable Timer1 Interrupt
	TIMER_ITConfig(MDR_TIMER1, TIMER_STATUS_CNT_ZERO, ENABLE);
	//Interrupt is active when TIMER1 value equals zero
	NVIC_SetPriority(Timer1_IRQn, 0);
	TIMER_Cmd(MDR_TIMER1, ENABLE); // Run TIMER1
}

void UART_ini(void)
{
	// Enable UART1 clocking
	RST_CLK_PCLKcmd (RST_CLK_PCLK_UART2, ENABLE);
	
	UART_InitTypeDef UARTInitStruct;
	
	UART_BRGInit(MDR_UART2, UART_HCLKdiv1);
	
	UARTInitStruct.UART_BaudRate			 = 9600;
	UARTInitStruct.UART_WordLength			 = UART_WordLength8b;
	UARTInitStruct.UART_StopBits			 = UART_StopBits1;
	UARTInitStruct.UART_Parity				 = UART_Parity_No;
	UARTInitStruct.UART_FIFOMode			 = UART_FIFO_OFF;
	UARTInitStruct.UART_HardwareFlowControl  = UART_HardwareFlowControl_TXE;
	// Initialize UART2
	UART_Init(MDR_UART2, &UARTInitStruct);
	// Turn on UART2
	UART_Cmd(MDR_UART2, ENABLE);
}

void ADC_ini(void)
{
	__IO uint32_t H_Level = 0x900;
	__IO uint32_t L_Level = 0x800;
	
	PORT_InitTypeDef PORT_InitStructure;
	ADC_InitTypeDef sADC;
	ADCx_InitTypeDef sADCx;
	
	RST_CLK_DeInit();
	RST_CLK_CPU_PLLconfig (RST_CLK_CPU_PLLsrcHSIdiv2,0);
	/* Enable peripheral clocks --------------------------------------------------*/
	RST_CLK_PCLKcmd((RST_CLK_PCLK_RST_CLK | RST_CLK_PCLK_ADC | RST_CLK_PCLK_PORTD),ENABLE);

	/* Init NVIC */
	SCB->AIRCR = 0x05FA0000 | ((uint32_t)0x500);
	SCB->VTOR = 0x08000000;
	/* Disable all interrupt */
	NVIC->ICPR[0] = 0xFFFFFFFF;
	NVIC->ICER[0] = 0xFFFFFFFF;

	/* Enable ADC interrupt  */
	NVIC->ISER[0] = (1<<ADC_IRQn);
	
	/* Reset PORTD settings */
	PORT_DeInit(MDR_PORTD);
	
	/* Configure ADC pin: ADC7 */
	/* Configure PORTD pin 7 */
	PORT_InitStructure.PORT_Pin   = PORT_Pin_7;
	PORT_InitStructure.PORT_OE    = PORT_OE_IN;
	PORT_InitStructure.PORT_MODE  = PORT_MODE_ANALOG;
	
	PORT_Init(MDR_PORTD, &PORT_InitStructure);
	
	/* Configure PORTD pins 10, 11 for output to switch LED1,2 on/off */ 
	/* Configure PORTD pins 10, 11 */
	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_PORT;
	PORT_InitStructure.PORT_Pin   = PORT_Pin_10 | PORT_Pin_11 | PORT_Pin_12;
	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
	
	PORT_Init(MDR_PORTD, &PORT_InitStructure);
	
	
	ADC_DeInit(); // Reset all ADC settings
	
	//Fills each ADC_InitStruct member with its default value
	ADC_StructInit(&sADC);
	
	/* Initializes the ADC peripheral according to
	the specified parameters in the ADC_InitStruct */
	ADC_Init(&sADC);
	
	//Fills each ADCx_InitStruct member with its default value.
	ADCx_StructInit (&sADCx);
	/*  ADCx_StructInit fills with default values
	*	sADCx.ADC_ClockSource 	   //Default ADC_CLOCK_SOURCE_CPU
	*	sADCx.ADC_SamplingMode	   //Default ADC_SAMPLING_MODE_SINGLE_CONV
	*	sADCx.ADC_ChannelSwitching //ADC_CH_SWITCHING_Disable
	*	sADCx.ADC_ChannelNumber	   //ADC_CH_ADC0
	*	sADCx.ADC_Channels		   //Default 0
	*	sADCx.ADC_LevelControl	   //Default ADC_LEVEL_CONTROL_Disable
	*	sADCx.ADC_LowLevel		   //Default 0
	*	sADCx.ADC_HighLevel		   //Default 0
	*	sADCx.ADC_VRefSource	   //Default ADC_VREF_SOURCE_INTERNAL
	*	sADCx.ADC_IntVRefSource	   //Default ADC_INT_VREF_SOURCE_INEXACT
	*	sADCx.ADC_Prescaler		   //Default ADC_CLK_div_None
	*	sADCx.ADC_DelayGo		   //Default 0
	*/
	sADCx.ADC_ClockSource      = ADC_CLOCK_SOURCE_CPU; //выбор источника тактирования, частота ядра
	sADCx.ADC_SamplingMode     = ADC_SAMPLING_MODE_CICLIC_CONV; //режим многократного преобразования
	sADCx.ADC_ChannelSwitching = ADC_CH_SWITCHING_Disable; // автоматическое переключение каналов
	sADCx.ADC_ChannelNumber    = ADC_CH_ADC7; //выбор номера канала
	sADCx.ADC_Channels         = 0; //количество используемых каналов, если включен перебор ADC_CH_SWITCHING_Enable
	sADCx.ADC_LevelControl     = ADC_LEVEL_CONTROL_Enable; // контроль уровня входного сигнала
	sADCx.ADC_LowLevel         = L_Level;//нижний уровень контроля
	sADCx.ADC_HighLevel        = H_Level; // верхний уровень
	sADCx.ADC_VRefSource       = ADC_VREF_SOURCE_INTERNAL; //выбор внутреннего источника опорного напряжения
	sADCx.ADC_IntVRefSource    = ADC_INT_VREF_SOURCE_INEXACT; //вид источника для датчика опорного напряжения
	sADCx.ADC_Prescaler        = ADC_CLK_div_32768; //выбор делителя тактовой частоты
	sADCx.ADC_DelayGo          = 0xF; //значение задержки перед началом следующего преобразования
	
	/* Initializes the ADC1 peripheral according to
	the specified parameters in the ADCx_InitStruct */
	ADC1_Init(&sADCx);
	
	/* Enable ADC1 EOCIF and AWOIFEN interupts */
	ADC1_ITConfig((ADCx_IT_END_OF_CONVERSION | ADCx_IT_OUT_OF_RANGE), ENABLE);

	/* ADC1 enable */
	ADC1_Cmd(ENABLE);
}


void Delay(int waitTicks)
{
	int i;
	for (i = 0; i < waitTicks; i++)
	{
		__NOP();
	}
}



int main(void)
{
	Ports_ini();
	Timer_ini();
	UART_ini();
	
	while (1)
	{
	}
}
