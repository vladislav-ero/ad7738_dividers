// Содержимое файла main.c

#include "MDR32Fx.h"                    // Device header
#include "MDR32F9Qx_config.h"           // Keil::Device:Startup


#include "MDR32F9Qx_uart.h"             // Keil::Drivers:UART
#include <MDR32F9Qx_port.h>
#include <MDR32F9Qx_rst_clk.h>
#include "MDR32F9Qx_timer.h"            // Keil::Drivers:TIMER

#define PLL_MUL  12					    // = RST_CLK_CPU_PLLmul16 + 1
#define CPU_FREQ HSE_Value * PLL_MUL
#define BAUDRATE 9600

#define DELAY(T) for (i = T; i > 0; i--) 
int i; 

#ifndef _UART_H
#define _UART_H

#define USE_UART1

#ifdef USE_UART2

	#define UART_X						MDR_UART2
	#define UART_IRQ					UART2_IRQn
	#define UART_CLOCK 				RST_CLK_PCLK_UART2	
	
	#ifdef USE_MDR1986VE9x
	
		#define UART_CLOCK_TX 		RST_CLK_PCLK_PORTF
		#define UART_CLOCK_RX 		RST_CLK_PCLK_PORTF
	
		#define UART_PORT_TX			MDR_PORTF
		#define UART_PORT_PinTX		PORT_Pin_1
		#define UART_PORT_FuncTX  PORT_FUNC_OVERRID
	
		#define UART_PORT_RX			MDR_PORTF	
		#define UART_PORT_PinRX		PORT_Pin_0
		#define UART_PORT_FuncRX  PORT_FUNC_OVERRID
	#endif
#elif defined ( USE_UART1 )
	#define UART_X					MDR_UART1
	#define UART_IRQ				UART1_IRQn
	#define UART_CLOCK 				RST_CLK_PCLK_UART1
	
	#ifdef USE_MDR1986VE9x
	
		#define UART_CLOCK_TX 		RST_CLK_PCLK_PORTA
		#define UART_CLOCK_RX 		RST_CLK_PCLK_PORTA
		
		#define UART_PORT_TX			MDR_PORTA
		#define UART_PORT_PinTX		PORT_Pin_7
		#define UART_PORT_FuncTX  PORT_FUNC_OVERRID
		
		#define UART_PORT_RX			MDR_PORTA	
		#define UART_PORT_PinRX		PORT_Pin_6
		#define UART_PORT_FuncRX  PORT_FUNC_OVERRID
	#endif
#endif
#endif
		

typedef enum {tskNoTask, tskChangeRate} UART_Task;

UART_Task ActiveTask = tskNoTask;

const uint32_t UART_Rates[] = {9600, 56000, 115200};

void UART(void);
void LED(void);
	

void Timer1_IRQHandler()
{
	// Check if TIMER1 interrupt has occured
	if (TIMER_GetITStatus(MDR_TIMER1, TIMER_STATUS_CNT_ZERO)) 
	{
		UART();
	}
	
	// Reset TIMER1 interruption flag
	TIMER_ClearITPendingBit(MDR_TIMER1, TIMER_STATUS_CNT_ZERO);
}

void UART(void) { //*
	static uint8_t uart_counter = 0;
	switch (uart_counter++ % 4) {
		case 0:
			{
				UART_SendData(MDR_UART2, 0x00);
				LED();
			}
			break;
		case 1:
			{
				UART_SendData(MDR_UART2, 0x01);
				LED();
			}
			break;
		case 2:
			{
				UART_SendData(MDR_UART2, 0x02);
				LED();
			}
			break;
		case 3:
			{
				UART_SendData(MDR_UART2, 0x03);
				LED();
			}
			break;
		case 4:
			{
				UART_SendData(MDR_UART2, 0x04);
				LED();
			}
			break;
		case 5:
			{
				UART_SendData(MDR_UART2, 0x05);
				LED();
			}
			break;
	} //*/
}

// Процедура включения/выключения светодиода 
void LED(void) { 
	// Объявление переменной i 
	static uint8_t led_counter = 0; 
	// Инкрементируя i, находить остаток от деления i на 2 
	switch (led_counter++ % 2) { 
		// В случае если остаток равен нулю, сбросить бит по линии 0 
		case 0: 
			PORT_ResetBits(MDR_PORTC, PORT_Pin_0); 
		// В противном случае перейти к следующей команде 
			break; 
		// В случае если остаток равен единице, установить бит по ли-нии 0 
		case 1: 
			PORT_SetBits(MDR_PORTC, PORT_Pin_0); 
		// В противном случае перейти к следующей команде 
			break; 
	} 
}

void Clock_Init_HSE_PLL(uint32_t PLL_Mul)  // 80 MHz
{
  // Сброс настроек системы тактирования
  RST_CLK_DeInit();

  // Инициализация генератора на внешнем кварцевом резонаторе (HSE)
  RST_CLK_HSEconfig (RST_CLK_HSE_ON);
  while (RST_CLK_HSEstatus() != SUCCESS);

  // Инициализация блока PLL
  // Включение использования PLL
  RST_CLK_CPU_PLLcmd (ENABLE);

  // Настройка источника и коэффициента умножения PLL
  // (CPU_C1_SEL = HSE)
  RST_CLK_CPU_PLLconfig (RST_CLK_CPU_PLLsrcHSEdiv1, PLL_Mul);
  while (RST_CLK_CPU_PLLstatus() != SUCCESS);

  // Подключение PLL к системе тактирования
  // (CPU_C2_SEL = PLLCPUo)
  RST_CLK_CPU_PLLuse (ENABLE);

  // Настройка коэффициента деления блока CPU_C3_SEL
  // (CPU_C3_SEL = CPU_C2)
  RST_CLK_CPUclkPrescaler (RST_CLK_CPUclkDIV1);

  // Использование процессором сигнала CPU_C3
  // (HCLK = CPU_C3)
  RST_CLK_CPUclkSelection (RST_CLK_CPUclkCPU_C3);
}

void UART_Initialize (uint32_t uartBaudRate)
{
  // Структура для инициализации линий ввода-вывода
  PORT_InitTypeDef GPIOInitStruct;

  // Структура для инициализации модуля UART
  UART_InitTypeDef UARTInitStruct;

  // Разрешение тактирования порта F и модуля UART
  RST_CLK_PCLKcmd (UART_CLOCK | UART_CLOCK_TX | UART_CLOCK_RX , ENABLE);

  // Общая конфигурация линий ввода-вывода
  PORT_StructInit (&GPIOInitStruct);
  GPIOInitStruct.PORT_SPEED = PORT_SPEED_MAXFAST;
  GPIOInitStruct.PORT_MODE  = PORT_MODE_DIGITAL;

  // Конфигурация и инициализация линии для приема данных 
	GPIOInitStruct.PORT_FUNC  = UART_PORT_FuncRX;
  GPIOInitStruct.PORT_OE    = PORT_OE_IN;
  GPIOInitStruct.PORT_Pin   = UART_PORT_PinRX;
  PORT_Init (UART_PORT_RX, &GPIOInitStruct);

  // Конфигурация и инициализация линии для передачи данных 
  GPIOInitStruct.PORT_FUNC  = UART_PORT_FuncTX;	
  GPIOInitStruct.PORT_OE    = PORT_OE_OUT;
  GPIOInitStruct.PORT_Pin   = UART_PORT_PinTX;
  PORT_Init (UART_PORT_TX, &GPIOInitStruct);

   // Конфигурация модуля UART
  UARTInitStruct.UART_BaudRate            = uartBaudRate;                  // Скорость передачи данных
  UARTInitStruct.UART_WordLength          = UART_WordLength8b;             // Количество битов данных в сообщении
  UARTInitStruct.UART_StopBits            = UART_StopBits1;                // Количество STOP-битов
  UARTInitStruct.UART_Parity              = UART_Parity_No;                // Контроль четности
  UARTInitStruct.UART_FIFOMode            = UART_FIFO_OFF;                 // Включение/отключение буфера
  UARTInitStruct.UART_HardwareFlowControl = UART_HardwareFlowControl_RXE   // Аппаратный контроль за передачей и приемом данных
                                          | UART_HardwareFlowControl_TXE;

  // Инициализация модуля UART
  UART_Init (UART_X, &UARTInitStruct);

  // Выбор предделителя тактовой частоты модуля UART
  UART_BRGInit (UART_X, UART_HCLKdiv1);

  // Выбор источников прерываний (прием и передача данных)
  UART_ITConfig (UART_X, UART_IT_RX | UART_IT_TX, ENABLE);

   // Разрешение работы модуля UART
  UART_Cmd (UART_X, ENABLE);
}

void UART_InitIRQ(uint32_t priority) // priority = 1

{
  // Назначение приоритета аппаратного прерывания от UART
  NVIC_SetPriority (UART_IRQ, priority);

  // Разрешение аппаратных прерываний от UART
  NVIC_EnableIRQ (UART_IRQ);
}

void UartSetBaud(uint32_t baudRate, uint32_t freqCPU)
{
	uint32_t divider = freqCPU / (baudRate >> 2);
	uint32_t CR_tmp = UART_X->CR;
	uint32_t LCR_tmp = UART_X->LCR_H;
	
//  while ( !(UART_X->FR & UART_FLAG_TXFE) ); // wait FIFO empty
	while ( (UART_X->FR & UART_FLAG_BUSY) )
	{}		// wait 

  UART_X->CR = 0;
  UART_X->IBRD = divider >> 6;
  UART_X->FBRD = divider & 0x003F;
  UART_X->LCR_H = LCR_tmp;
  UART_X->CR = CR_tmp;
}

void Ports_ini(void)
{
	PORT_InitTypeDef NastroykaUART; 
	RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTF, ENABLE); 
	PORT_StructInit(&NastroykaUART);
	// Operation in UART mode 
	NastroykaUART.PORT_FUNC  = PORT_FUNC_OVERRID;
	NastroykaUART.PORT_SPEED = PORT_SPEED_MAXFAST;
	NastroykaUART.PORT_MODE  = PORT_MODE_DIGITAL;	
	// PF1 as UART_TX
	NastroykaUART.PORT_Pin   = PORT_Pin_1;
	NastroykaUART.PORT_OE    = PORT_OE_OUT;
	PORT_Init(MDR_PORTF, &NastroykaUART);
	// PF0 as UART_RX
	NastroykaUART.PORT_Pin   = PORT_Pin_0;
	NastroykaUART.PORT_OE    = PORT_OE_IN;
	PORT_Init(MDR_PORTF, &NastroykaUART);
	
	PORT_InitTypeDef NastroykaLED; 
	RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTC, ENABLE); 
	PORT_StructInit(&NastroykaLED); 
	NastroykaLED.PORT_Pin   = PORT_Pin_0; 
	NastroykaLED.PORT_OE    = PORT_OE_OUT;
	NastroykaLED.PORT_FUNC  = PORT_FUNC_PORT; 
	NastroykaLED.PORT_MODE  = PORT_MODE_DIGITAL; 
	NastroykaLED.PORT_SPEED = PORT_SPEED_SLOW; 
	PORT_Init(MDR_PORTC, &NastroykaLED);
}

void Timer_ini(void)
{
	RST_CLK_PCLKcmd(RST_CLK_PCLK_TIMER1, ENABLE); // Enable Timer1 clocking
	TIMER_CntInitTypeDef TimerInitStruct;
	TIMER_CntStructInit(&TimerInitStruct);
	
	TIMER_BRGInit(MDR_TIMER1, TIMER_HCLKdiv1); // Set clock divider

	TimerInitStruct.TIMER_Prescaler = 65535; // CPUclk 128M div n == 65536 Hz (1 ms)
	TimerInitStruct.TIMER_Period    = 15258;  // 1 ms * n == n ms
	
	TIMER_CntInit(MDR_TIMER1, &TimerInitStruct);
	
	NVIC_EnableIRQ(Timer1_IRQn); // Enable Timer1 Interrupt
	TIMER_ITConfig(MDR_TIMER1, TIMER_STATUS_CNT_ZERO, ENABLE);
	//Interrupt is active when TIMER1 value equals zero
	NVIC_SetPriority(Timer1_IRQn, 0);
	TIMER_Cmd(MDR_TIMER1, ENABLE); // Run TIMER1
}

void UART_ini(void)
{
	// Enable UART2 clocking
	RST_CLK_PCLKcmd(RST_CLK_PCLK_UART2, ENABLE);
	UART_InitTypeDef UARTInitStruct;
	
	UARTInitStruct.UART_BaudRate			 = 9600;
	UARTInitStruct.UART_WordLength			 = UART_WordLength8b;
	UARTInitStruct.UART_StopBits			 = UART_StopBits1;
	UARTInitStruct.UART_Parity				 = UART_Parity_No;
	UARTInitStruct.UART_FIFOMode			 = UART_FIFO_OFF;
	UARTInitStruct.UART_HardwareFlowControl  = UART_HardwareFlowControl_RXE
											 | UART_HardwareFlowControl_TXE;
	
	//UARTInitStruct.UART_HardwareFlowControl  = UART_HardwareFlowControl_None;
	// Initialize UART2
	UART_Init(MDR_UART2, &UARTInitStruct);
	UART_BRGInit(MDR_UART2, UART_HCLKdiv1);
	// Turn on UART2
	UART_Cmd(MDR_UART2, ENABLE);
}




int main(void)
{
	Clock_Init_HSE_PLL(PLL_MUL - 1);
	UART_Initialize(UART_Rates[2]);
	UART_InitIRQ(1);
	//Ports_ini();
	//Timer_ini();
	//UART_ini();
	
	while (1)
	{
		/*
		UART_SendData(MDR_UART2, 'U'); 
		// Передать символ U 
		DELAY(500000); 
		// Задержка 
		UART_SendData(MDR_UART2, 'A'); 
		// Передать символ A 
		DELAY(500000); 
		// Задержка 
		UART_SendData(MDR_UART2, 'R'); 
		// Передать символ R 
		DELAY(50000); 
		// Задержка 
		UART_SendData(MDR_UART2, 'T'); 
		// Передать символ T 
		DELAY(500000); 
		// Задержка 
		UART_SendData(MDR_UART2, '\n'); 
		// Перевод строки 
		DELAY(50000); 
		// Задержка
		UART_SendData(MDR_UART2, '\r'); 
		// Возврат каретки 
		DELAY(5000000); 
		// Задержка
		*/
	}
}

void UART_Handler_RX_TX(void)
{	
	uint16_t receivedData;
	
  // Обработка прерывания по Приему данных
  if (UART_GetITStatusMasked (UART_X, UART_IT_RX) == SET)
  {
    // Сброс прерывания
    UART_ClearITPendingBit (UART_X, UART_IT_RX);

    // Получаем данные и отвечаем - ЭХО
		receivedData = UART_ReceiveData (UART_X);
		UART_SendData (UART_X, receivedData);
		
		// Если активная задача - смена скорости
		if (ActiveTask == tskChangeRate)
		{
			ActiveTask = tskNoTask;

			//	Если индекс скорости в заданных пределах, то меняем скорость
			if (receivedData < 3)
				UartSetBaud(UART_Rates[receivedData], CPU_FREQ);
		}

		//  При получении символа 'R', следующим байтом ожидаем индекс новой скорости
		if (receivedData == 'R')
			ActiveTask = tskChangeRate;			
  }
	
  // Обработка прерывания от Передачи данных
  if (UART_GetITStatusMasked(UART_X, UART_IT_TX) == SET)
  {
    // Сброс прерывания
    UART_ClearITPendingBit (UART_X, UART_IT_TX);
  }	
}

void UART1_IRQHandler (void)
{
	UART_Handler_RX_TX();
}

void UART2_IRQHandler (void)
{
	UART_Handler_RX_TX();
}
